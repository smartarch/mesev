/*
 * generated by Xtext 2.39.0-SNAPSHOT
 */
package com.mesev.dsl.serializer;

import com.google.inject.Inject;
import com.mesev.dsl.services.XDSLGrammarAccess;
import com.mesev.dsl.xDSL.ActionArgument;
import com.mesev.dsl.xDSL.Array;
import com.mesev.dsl.xDSL.AssembledWorkflow;
import com.mesev.dsl.xDSL.Attribute;
import com.mesev.dsl.xDSL.Case;
import com.mesev.dsl.xDSL.CompositeWorkflow;
import com.mesev.dsl.xDSL.ConditionalExpLink;
import com.mesev.dsl.xDSL.ConditionalLink;
import com.mesev.dsl.xDSL.Control;
import com.mesev.dsl.xDSL.DataConfiguration;
import com.mesev.dsl.xDSL.DataConnection;
import com.mesev.dsl.xDSL.DataLink;
import com.mesev.dsl.xDSL.Event;
import com.mesev.dsl.xDSL.ExceptionalLink;
import com.mesev.dsl.xDSL.Exclusive;
import com.mesev.dsl.xDSL.Experiment;
import com.mesev.dsl.xDSL.ExperimentTask;
import com.mesev.dsl.xDSL.ExperimentTaskConfiguraiton;
import com.mesev.dsl.xDSL.ExperimentTaskConfiguraitonBody;
import com.mesev.dsl.xDSL.Field;
import com.mesev.dsl.xDSL.Group;
import com.mesev.dsl.xDSL.Inclusive;
import com.mesev.dsl.xDSL.InputData;
import com.mesev.dsl.xDSL.Interaction;
import com.mesev.dsl.xDSL.Join;
import com.mesev.dsl.xDSL.MetaData;
import com.mesev.dsl.xDSL.Metric;
import com.mesev.dsl.xDSL.Node;
import com.mesev.dsl.xDSL.OutputData;
import com.mesev.dsl.xDSL.Parallel;
import com.mesev.dsl.xDSL.ParallelNodes;
import com.mesev.dsl.xDSL.Param;
import com.mesev.dsl.xDSL.ParamValue;
import com.mesev.dsl.xDSL.ParamValueEnum;
import com.mesev.dsl.xDSL.ParamValueList;
import com.mesev.dsl.xDSL.ParamValueRange;
import com.mesev.dsl.xDSL.PrimitiveType;
import com.mesev.dsl.xDSL.RegularExpLink;
import com.mesev.dsl.xDSL.RegularLink;
import com.mesev.dsl.xDSL.Root;
import com.mesev.dsl.xDSL.Space;
import com.mesev.dsl.xDSL.Structure;
import com.mesev.dsl.xDSL.Task;
import com.mesev.dsl.xDSL.TaskConfiguration;
import com.mesev.dsl.xDSL.TaskConfigurationBody;
import com.mesev.dsl.xDSL.TaskSpecification;
import com.mesev.dsl.xDSL.XDSLPackage;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class XDSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private XDSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == XDSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case XDSLPackage.ACTION:
				sequence_Action(context, (com.mesev.dsl.xDSL.Action) semanticObject); 
				return; 
			case XDSLPackage.ACTION_ARGUMENT:
				sequence_ActionArgument(context, (ActionArgument) semanticObject); 
				return; 
			case XDSLPackage.ARRAY:
				sequence_Array(context, (Array) semanticObject); 
				return; 
			case XDSLPackage.ASSEMBLED_WORKFLOW:
				sequence_AssembledWorkflow(context, (AssembledWorkflow) semanticObject); 
				return; 
			case XDSLPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case XDSLPackage.CASE:
				sequence_Case(context, (Case) semanticObject); 
				return; 
			case XDSLPackage.COMPOSITE_WORKFLOW:
				sequence_CompositeWorkflow(context, (CompositeWorkflow) semanticObject); 
				return; 
			case XDSLPackage.CONDITIONAL_EXP_LINK:
				sequence_ConditionalExpLink(context, (ConditionalExpLink) semanticObject); 
				return; 
			case XDSLPackage.CONDITIONAL_LINK:
				sequence_ConditionalLink(context, (ConditionalLink) semanticObject); 
				return; 
			case XDSLPackage.CONTROL:
				sequence_Control(context, (Control) semanticObject); 
				return; 
			case XDSLPackage.DATA_CONFIGURATION:
				sequence_DataConfiguration(context, (DataConfiguration) semanticObject); 
				return; 
			case XDSLPackage.DATA_CONNECTION:
				sequence_DataConnection(context, (DataConnection) semanticObject); 
				return; 
			case XDSLPackage.DATA_LINK:
				sequence_DataLink(context, (DataLink) semanticObject); 
				return; 
			case XDSLPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case XDSLPackage.EXCEPTIONAL_LINK:
				sequence_ExceptionalLink(context, (ExceptionalLink) semanticObject); 
				return; 
			case XDSLPackage.EXCLUSIVE:
				sequence_Exclusive(context, (Exclusive) semanticObject); 
				return; 
			case XDSLPackage.EXPERIMENT:
				sequence_Experiment(context, (Experiment) semanticObject); 
				return; 
			case XDSLPackage.EXPERIMENT_TASK:
				sequence_ExperimentTask(context, (ExperimentTask) semanticObject); 
				return; 
			case XDSLPackage.EXPERIMENT_TASK_CONFIGURAITON:
				sequence_ExperimentTaskConfiguraiton(context, (ExperimentTaskConfiguraiton) semanticObject); 
				return; 
			case XDSLPackage.EXPERIMENT_TASK_CONFIGURAITON_BODY:
				sequence_ExperimentTaskConfiguraitonBody(context, (ExperimentTaskConfiguraitonBody) semanticObject); 
				return; 
			case XDSLPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case XDSLPackage.GROUP:
				sequence_Group(context, (Group) semanticObject); 
				return; 
			case XDSLPackage.INCLUSIVE:
				sequence_Inclusive(context, (Inclusive) semanticObject); 
				return; 
			case XDSLPackage.INPUT_DATA:
				sequence_InputData(context, (InputData) semanticObject); 
				return; 
			case XDSLPackage.INTERACTION:
				sequence_Interaction(context, (Interaction) semanticObject); 
				return; 
			case XDSLPackage.JOIN:
				sequence_Join(context, (Join) semanticObject); 
				return; 
			case XDSLPackage.META_DATA:
				sequence_MetaData(context, (MetaData) semanticObject); 
				return; 
			case XDSLPackage.METRIC:
				sequence_Metric(context, (Metric) semanticObject); 
				return; 
			case XDSLPackage.NODE:
				sequence_LinkableNode(context, (Node) semanticObject); 
				return; 
			case XDSLPackage.OUTPUT_DATA:
				sequence_OutputData(context, (OutputData) semanticObject); 
				return; 
			case XDSLPackage.PARALLEL:
				sequence_Parallel(context, (Parallel) semanticObject); 
				return; 
			case XDSLPackage.PARALLEL_NODES:
				sequence_ParallelNodes(context, (ParallelNodes) semanticObject); 
				return; 
			case XDSLPackage.PARAM:
				sequence_Param(context, (Param) semanticObject); 
				return; 
			case XDSLPackage.PARAM_VALUE:
				sequence_ParamValue(context, (ParamValue) semanticObject); 
				return; 
			case XDSLPackage.PARAM_VALUE_ENUM:
				sequence_ParamValueEnum(context, (ParamValueEnum) semanticObject); 
				return; 
			case XDSLPackage.PARAM_VALUE_LIST:
				sequence_ParamValueList(context, (ParamValueList) semanticObject); 
				return; 
			case XDSLPackage.PARAM_VALUE_RANGE:
				sequence_ParamValueRange(context, (ParamValueRange) semanticObject); 
				return; 
			case XDSLPackage.PARAMETER:
				sequence_Parameter(context, (com.mesev.dsl.xDSL.Parameter) semanticObject); 
				return; 
			case XDSLPackage.PRIMITIVE_TYPE:
				sequence_PrimitiveType(context, (PrimitiveType) semanticObject); 
				return; 
			case XDSLPackage.REGULAR_EXP_LINK:
				sequence_RegularExpLink(context, (RegularExpLink) semanticObject); 
				return; 
			case XDSLPackage.REGULAR_LINK:
				sequence_RegularLink(context, (RegularLink) semanticObject); 
				return; 
			case XDSLPackage.ROOT:
				sequence_Root(context, (Root) semanticObject); 
				return; 
			case XDSLPackage.SPACE:
				sequence_Space(context, (Space) semanticObject); 
				return; 
			case XDSLPackage.STRUCTURE:
				sequence_Structure(context, (Structure) semanticObject); 
				return; 
			case XDSLPackage.TASK:
				sequence_Task(context, (Task) semanticObject); 
				return; 
			case XDSLPackage.TASK_CONFIGURATION:
				sequence_TaskConfiguration(context, (TaskConfiguration) semanticObject); 
				return; 
			case XDSLPackage.TASK_CONFIGURATION_BODY:
				sequence_TaskConfigurationBody(context, (TaskConfigurationBody) semanticObject); 
				return; 
			case XDSLPackage.TASK_SPECIFICATION:
				sequence_TaskSpecification(context, (TaskSpecification) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     ActionArgument returns ActionArgument
	 *
	 * Constraint:
	 *     (string=STRING | id=ID)
	 * </pre>
	 */
	protected void sequence_ActionArgument(ISerializationContext context, ActionArgument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns Action
	 *
	 * Constraint:
	 *     (actionName=ID (arguments+=ActionArgument arguments+=ActionArgument*)?)
	 * </pre>
	 */
	protected void sequence_Action(ISerializationContext context, com.mesev.dsl.xDSL.Action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterType returns Array
	 *     Array returns Array
	 *
	 * Constraint:
	 *     (name=ID length=INT type=ParameterType?)
	 * </pre>
	 */
	protected void sequence_Array(ISerializationContext context, Array semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Workflow returns AssembledWorkflow
	 *     AssembledWorkflow returns AssembledWorkflow
	 *     ComponentWithData returns AssembledWorkflow
	 *
	 * Constraint:
	 *     (name=ID parent=[Workflow|ID] (inputs+=InputData | outputs+=OutputData | taskConfigurations+=TaskConfiguration)*)
	 * </pre>
	 */
	protected void sequence_AssembledWorkflow(ISerializationContext context, AssembledWorkflow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (name=ID attributeValue=ParamValue)
	 * </pre>
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.ATTRIBUTE__NAME));
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.ATTRIBUTE__ATTRIBUTE_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.ATTRIBUTE__ATTRIBUTE_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAttributeAccess().getAttributeValueParamValueParserRuleCall_2_0(), semanticObject.getAttributeValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Case returns Case
	 *
	 * Constraint:
	 *     (case=STRING target=[Node|ID])
	 * </pre>
	 */
	protected void sequence_Case(ISerializationContext context, Case semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.CASE__CASE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.CASE__CASE));
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.CASE__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.CASE__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCaseAccess().getCaseSTRINGTerminalRuleCall_0_0(), semanticObject.getCase());
		feeder.accept(grammarAccess.getCaseAccess().getTargetNodeIDTerminalRuleCall_1_0_1(), semanticObject.eGet(XDSLPackage.Literals.CASE__TARGET, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Workflow returns CompositeWorkflow
	 *     CompositeWorkflow returns CompositeWorkflow
	 *     ComponentWithData returns CompositeWorkflow
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             inputs+=InputData | 
	 *             outputs+=OutputData | 
	 *             tasks+=Task | 
	 *             dataConfigurations+=DataConfiguration | 
	 *             links+=Link | 
	 *             dataLinks+=DataLink | 
	 *             nodes+=Node
	 *         )*
	 *     )
	 * </pre>
	 */
	protected void sequence_CompositeWorkflow(ISerializationContext context, CompositeWorkflow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExperimentFlow returns ConditionalExpLink
	 *     ConditionalExpLink returns ConditionalExpLink
	 *
	 * Constraint:
	 *     (fromNode=[ExperimentNode|ID] toNode=[ExperimentNode|ID] condition=STRING)
	 * </pre>
	 */
	protected void sequence_ConditionalExpLink(ISerializationContext context, ConditionalExpLink semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.CONDITIONAL_EXP_LINK__FROM_NODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.CONDITIONAL_EXP_LINK__FROM_NODE));
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.CONDITIONAL_EXP_LINK__TO_NODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.CONDITIONAL_EXP_LINK__TO_NODE));
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.CONDITIONAL_EXP_LINK__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.CONDITIONAL_EXP_LINK__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalExpLinkAccess().getFromNodeExperimentNodeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(XDSLPackage.Literals.CONDITIONAL_EXP_LINK__FROM_NODE, false));
		feeder.accept(grammarAccess.getConditionalExpLinkAccess().getToNodeExperimentNodeIDTerminalRuleCall_2_0_1(), semanticObject.eGet(XDSLPackage.Literals.CONDITIONAL_EXP_LINK__TO_NODE, false));
		feeder.accept(grammarAccess.getConditionalExpLinkAccess().getConditionSTRINGTerminalRuleCall_5_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Link returns ConditionalLink
	 *     ConditionalLink returns ConditionalLink
	 *
	 * Constraint:
	 *     (input=LinkableNode output=LinkableNode (condition=STRING | cases+=Case+))
	 * </pre>
	 */
	protected void sequence_ConditionalLink(ISerializationContext context, ConditionalLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Control returns Control
	 *
	 * Constraint:
	 *     (flows+=ExperimentFlow+ | notImplemented='...')?
	 * </pre>
	 */
	protected void sequence_Control(ISerializationContext context, Control semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataConfiguration returns DataConfiguration
	 *
	 * Constraint:
	 *     (data=[Data|ID] (path=STRING | type=STRING | defaultValue=ParamValue)*)
	 * </pre>
	 */
	protected void sequence_DataConfiguration(ISerializationContext context, DataConfiguration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataConnection returns DataConnection
	 *
	 * Constraint:
	 *     ((component=[ComponentWithData|ID] fromComponent?='.')? ref=[Data|ID])
	 * </pre>
	 */
	protected void sequence_DataConnection(ISerializationContext context, DataConnection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataLink returns DataLink
	 *
	 * Constraint:
	 *     (inputData=GlobalID outputData=GlobalID)
	 * </pre>
	 */
	protected void sequence_DataLink(ISerializationContext context, DataLink semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.DATA_LINK__INPUT_DATA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.DATA_LINK__INPUT_DATA));
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.DATA_LINK__OUTPUT_DATA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.DATA_LINK__OUTPUT_DATA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataLinkAccess().getInputDataGlobalIDParserRuleCall_0_0(), semanticObject.getInputData());
		feeder.accept(grammarAccess.getDataLinkAccess().getOutputDataGlobalIDParserRuleCall_2_0(), semanticObject.getOutputData());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Node returns Event
	 *     Event returns Event
	 *     LinkableNode returns Event
	 *
	 * Constraint:
	 *     eventValue=EventValue
	 * </pre>
	 */
	protected void sequence_Event(ISerializationContext context, Event semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.EVENT__EVENT_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.EVENT__EVENT_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEventAccess().getEventValueEventValueEnumRuleCall_0(), semanticObject.getEventValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Link returns ExceptionalLink
	 *     ExceptionalLink returns ExceptionalLink
	 *
	 * Constraint:
	 *     (input=LinkableNode output=LinkableNode event=STRING)
	 * </pre>
	 */
	protected void sequence_ExceptionalLink(ISerializationContext context, ExceptionalLink semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.LINK__INPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.LINK__INPUT));
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.EXCEPTIONAL_LINK__OUTPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.EXCEPTIONAL_LINK__OUTPUT));
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.EXCEPTIONAL_LINK__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.EXCEPTIONAL_LINK__EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExceptionalLinkAccess().getInputLinkableNodeParserRuleCall_0_0(), semanticObject.getInput());
		feeder.accept(grammarAccess.getExceptionalLinkAccess().getOutputLinkableNodeParserRuleCall_2_0(), semanticObject.getOutput());
		feeder.accept(grammarAccess.getExceptionalLinkAccess().getEventSTRINGTerminalRuleCall_5_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Operator returns Exclusive
	 *     Exclusive returns Exclusive
	 *     LinkableNode returns Exclusive
	 *
	 * Constraint:
	 *     id=EXCLUSIVE_TERM
	 * </pre>
	 */
	protected void sequence_Exclusive(ISerializationContext context, Exclusive semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.OPERATOR__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.OPERATOR__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExclusiveAccess().getIdEXCLUSIVE_TERMTerminalRuleCall_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExperimentTaskConfiguraitonBody returns ExperimentTaskConfiguraitonBody
	 *
	 * Constraint:
	 *     (params+=Param+ | notImplemented='...')?
	 * </pre>
	 */
	protected void sequence_ExperimentTaskConfiguraitonBody(ISerializationContext context, ExperimentTaskConfiguraitonBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExperimentTaskConfiguraiton returns ExperimentTaskConfiguraiton
	 *
	 * Constraint:
	 *     (task=[Task|ID] taskConfiguration=ExperimentTaskConfiguraitonBody)
	 * </pre>
	 */
	protected void sequence_ExperimentTaskConfiguraiton(ISerializationContext context, ExperimentTaskConfiguraiton semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.EXPERIMENT_TASK_CONFIGURAITON__TASK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.EXPERIMENT_TASK_CONFIGURAITON__TASK));
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.EXPERIMENT_TASK_CONFIGURAITON__TASK_CONFIGURATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.EXPERIMENT_TASK_CONFIGURAITON__TASK_CONFIGURATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExperimentTaskConfiguraitonAccess().getTaskTaskIDTerminalRuleCall_1_0_1(), semanticObject.eGet(XDSLPackage.Literals.EXPERIMENT_TASK_CONFIGURAITON__TASK, false));
		feeder.accept(grammarAccess.getExperimentTaskConfiguraitonAccess().getTaskConfigurationExperimentTaskConfiguraitonBodyParserRuleCall_2_0(), semanticObject.getTaskConfiguration());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExperimentTask returns ExperimentTask
	 *     ExperimentNode returns ExperimentTask
	 *
	 * Constraint:
	 *     ((abstract?='task' name=ID) | (configured?='task' name=ID taskConfiguration=TaskConfigurationBody))
	 * </pre>
	 */
	protected void sequence_ExperimentTask(ISerializationContext context, ExperimentTask semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Experiment returns Experiment
	 *
	 * Constraint:
	 *     (name=ID intent=ID? (interactions+=Interaction | spaces+=Space | control=Control | tasks+=ExperimentTask)*)
	 * </pre>
	 */
	protected void sequence_Experiment(ISerializationContext context, Experiment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Field returns Field
	 *
	 * Constraint:
	 *     (name=ID type=ParameterType?)
	 * </pre>
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Group returns Group
	 *
	 * Constraint:
	 *     (name=ID tasks+=Task)
	 * </pre>
	 */
	protected void sequence_Group(ISerializationContext context, Group semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Operator returns Inclusive
	 *     Inclusive returns Inclusive
	 *     LinkableNode returns Inclusive
	 *
	 * Constraint:
	 *     id=INCLUSIVE_TERM
	 * </pre>
	 */
	protected void sequence_Inclusive(ISerializationContext context, Inclusive semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.OPERATOR__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.OPERATOR__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInclusiveAccess().getIdINCLUSIVE_TERMTerminalRuleCall_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Data returns InputData
	 *     InputData returns InputData
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_InputData(ISerializationContext context, InputData semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.DATA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.DATA__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputDataAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Interaction returns Interaction
	 *     ExperimentNode returns Interaction
	 *
	 * Constraint:
	 *     (name=ID (tasks+=Action+ | notImplemented='...')?)
	 * </pre>
	 */
	protected void sequence_Interaction(ISerializationContext context, Interaction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Operator returns Join
	 *     Join returns Join
	 *     LinkableNode returns Join
	 *
	 * Constraint:
	 *     id=JOIN_TERM
	 * </pre>
	 */
	protected void sequence_Join(ISerializationContext context, Join semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.OPERATOR__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.OPERATOR__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJoinAccess().getIdJOIN_TERMTerminalRuleCall_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LinkableNode returns Node
	 *
	 * Constraint:
	 *     ref=[Node|ID]
	 * </pre>
	 */
	protected void sequence_LinkableNode(ISerializationContext context, Node semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.NODE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.NODE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLinkableNodeAccess().getRefNodeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(XDSLPackage.Literals.NODE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MetaData returns MetaData
	 *
	 * Constraint:
	 *     (name=STRING value=STRING)
	 * </pre>
	 */
	protected void sequence_MetaData(ISerializationContext context, MetaData semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.META_DATA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.META_DATA__NAME));
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.META_DATA__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.META_DATA__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMetaDataAccess().getNameSTRINGTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMetaDataAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Metric returns Metric
	 *
	 * Constraint:
	 *     (name=ID (type=ParameterType | kind=MetricKind)*)
	 * </pre>
	 */
	protected void sequence_Metric(ISerializationContext context, Metric semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Data returns OutputData
	 *     OutputData returns OutputData
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_OutputData(ISerializationContext context, OutputData semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.DATA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.DATA__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutputDataAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParallelNodes returns ParallelNodes
	 *
	 * Constraint:
	 *     (nodes+=[ExperimentNode|ID] nodes+=[ExperimentNode|ID]+)
	 * </pre>
	 */
	protected void sequence_ParallelNodes(ISerializationContext context, ParallelNodes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Operator returns Parallel
	 *     Parallel returns Parallel
	 *     LinkableNode returns Parallel
	 *
	 * Constraint:
	 *     id=PARALLEL_TERM
	 * </pre>
	 */
	protected void sequence_Parallel(ISerializationContext context, Parallel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.OPERATOR__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.OPERATOR__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParallelAccess().getIdPARALLEL_TERMTerminalRuleCall_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParamValueEnum returns ParamValueEnum
	 *
	 * Constraint:
	 *     (values+=PrimitiveValue values+=PrimitiveValue*)
	 * </pre>
	 */
	protected void sequence_ParamValueEnum(ISerializationContext context, ParamValueEnum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParamValueList returns ParamValueList
	 *
	 * Constraint:
	 *     (values+=PrimitiveValue values+=PrimitiveValue*)
	 * </pre>
	 */
	protected void sequence_ParamValueList(ISerializationContext context, ParamValueList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParamValueRange returns ParamValueRange
	 *
	 * Constraint:
	 *     (start=INT end=INT step=INT?)
	 * </pre>
	 */
	protected void sequence_ParamValueRange(ISerializationContext context, ParamValueRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParamValue returns ParamValue
	 *
	 * Constraint:
	 *     (rangeValue=ParamValueRange | enumValue=ParamValueEnum | primitiveValue=PrimitiveValue | listValue=ParamValueList)
	 * </pre>
	 */
	protected void sequence_ParamValue(ISerializationContext context, ParamValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Param returns Param
	 *
	 * Constraint:
	 *     (name=ID (assigned?='=' (value=ParamValue | ref=[Param|ID]))?)
	 * </pre>
	 */
	protected void sequence_Param(ISerializationContext context, Param semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             type=ParameterType | 
	 *             defaultValueString=STRING | 
	 *             defaultValueInt=INT | 
	 *             rangeValue=ParamValueRange | 
	 *             enumValue=ParamValueEnum | 
	 *             valueConstraint=STRING
	 *         )*
	 *     )
	 * </pre>
	 */
	protected void sequence_Parameter(ISerializationContext context, com.mesev.dsl.xDSL.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterType returns PrimitiveType
	 *     PrimitiveType returns PrimitiveType
	 *
	 * Constraint:
	 *     {PrimitiveType}
	 * </pre>
	 */
	protected void sequence_PrimitiveType(ISerializationContext context, PrimitiveType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExperimentFlow returns RegularExpLink
	 *     RegularExpLink returns RegularExpLink
	 *
	 * Constraint:
	 *     (
	 *         started?='START'? 
	 *         (nodes+=[ExperimentNode|ID] | parallelNodes+=ParallelNodes) 
	 *         nodes+=[ExperimentNode|ID]? 
	 *         (parallelNodes+=ParallelNodes? nodes+=[ExperimentNode|ID]?)* 
	 *         ended?='-&gt;'?
	 *     )
	 * </pre>
	 */
	protected void sequence_RegularExpLink(ISerializationContext context, RegularExpLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Link returns RegularLink
	 *     RegularLink returns RegularLink
	 *
	 * Constraint:
	 *     (input=LinkableNode ouput+=LinkableNode+)
	 * </pre>
	 */
	protected void sequence_RegularLink(ISerializationContext context, RegularLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Root returns Root
	 *
	 * Constraint:
	 *     (
	 *         (asPackage?='package' name=ID) | 
	 *         ((asPackage?='package' name=ID) (workflows+=Workflow | groups+=Group | parameterTypes+=ParameterType | experiments+=Experiment)+)
	 *     )?
	 * </pre>
	 */
	protected void sequence_Root(ISerializationContext context, Root semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Space returns Space
	 *     ExperimentNode returns Space
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         assembledWorkflow=[Workflow|ID] 
	 *         ((strategy=ID | params+=Param | attributes+=Attribute | taskConfigurations+=ExperimentTaskConfiguraiton)+ | notImplemented='...')?
	 *     )
	 * </pre>
	 */
	protected void sequence_Space(ISerializationContext context, Space semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterType returns Structure
	 *     Structure returns Structure
	 *
	 * Constraint:
	 *     (name=ID fields+=Field)
	 * </pre>
	 */
	protected void sequence_Structure(ISerializationContext context, Structure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TaskConfigurationBody returns TaskConfigurationBody
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (
	 *                 inputs+=InputData | 
	 *                 outputs+=OutputData | 
	 *                 params+=Param | 
	 *                 description=STRING | 
	 *                 primitiveImplementation=STRING | 
	 *                 subworkflow=STRING | 
	 *                 dependency=STRING
	 *             )? 
	 *             (metadata+=MetaData metadata+=MetaData)?
	 *         )+ | 
	 *         notImplemented='...'
	 *     )?
	 * </pre>
	 */
	protected void sequence_TaskConfigurationBody(ISerializationContext context, TaskConfigurationBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TaskConfiguration returns TaskConfiguration
	 *     ComponentWithData returns TaskConfiguration
	 *
	 * Constraint:
	 *     (task=[Task|ID] taskConfiguration=TaskConfigurationBody)
	 * </pre>
	 */
	protected void sequence_TaskConfiguration(ISerializationContext context, TaskConfiguration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.TASK_CONFIGURATION__TASK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.TASK_CONFIGURATION__TASK));
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.TASK_CONFIGURATION__TASK_CONFIGURATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.TASK_CONFIGURATION__TASK_CONFIGURATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTaskConfigurationAccess().getTaskTaskIDTerminalRuleCall_1_0_1(), semanticObject.eGet(XDSLPackage.Literals.TASK_CONFIGURATION__TASK, false));
		feeder.accept(grammarAccess.getTaskConfigurationAccess().getTaskConfigurationTaskConfigurationBodyParserRuleCall_2_0(), semanticObject.getTaskConfiguration());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Workflow returns TaskSpecification
	 *     TaskSpecification returns TaskSpecification
	 *     ComponentWithData returns TaskSpecification
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             inputs+=InputData | 
	 *             outputs+=OutputData | 
	 *             metrics+=Metric | 
	 *             parameters+=Parameter | 
	 *             implementation=STRING | 
	 *             dependency=STRING
	 *         )*
	 *     )
	 * </pre>
	 */
	protected void sequence_TaskSpecification(ISerializationContext context, TaskSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Node returns Task
	 *     Task returns Task
	 *
	 * Constraint:
	 *     ((abstract?='task' name=ID) | (configured?='task' name=ID taskConfiguration=TaskConfigurationBody))
	 * </pre>
	 */
	protected void sequence_Task(ISerializationContext context, Task semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
