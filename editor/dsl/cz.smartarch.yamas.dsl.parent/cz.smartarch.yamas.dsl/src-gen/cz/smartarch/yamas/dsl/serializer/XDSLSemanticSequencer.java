/*
 * generated by Xtext 2.39.0-SNAPSHOT
 */
package cz.smartarch.yamas.dsl.serializer;

import com.google.inject.Inject;
import cz.smartarch.yamas.dsl.services.XDSLGrammarAccess;
import cz.smartarch.yamas.dsl.xDSL.ActionArgument;
import cz.smartarch.yamas.dsl.xDSL.Array;
import cz.smartarch.yamas.dsl.xDSL.AssembledWorkflow;
import cz.smartarch.yamas.dsl.xDSL.Attribute;
import cz.smartarch.yamas.dsl.xDSL.Case;
import cz.smartarch.yamas.dsl.xDSL.CompositeWorkflow;
import cz.smartarch.yamas.dsl.xDSL.Condition;
import cz.smartarch.yamas.dsl.xDSL.ConditionalExpLink;
import cz.smartarch.yamas.dsl.xDSL.ConditionalLink;
import cz.smartarch.yamas.dsl.xDSL.Control;
import cz.smartarch.yamas.dsl.xDSL.DataConfiguration;
import cz.smartarch.yamas.dsl.xDSL.DataLink;
import cz.smartarch.yamas.dsl.xDSL.Dependency;
import cz.smartarch.yamas.dsl.xDSL.Event;
import cz.smartarch.yamas.dsl.xDSL.ExceptionalLink;
import cz.smartarch.yamas.dsl.xDSL.Exclusive;
import cz.smartarch.yamas.dsl.xDSL.Experiment;
import cz.smartarch.yamas.dsl.xDSL.ExperimentSpace;
import cz.smartarch.yamas.dsl.xDSL.ExperimentTask;
import cz.smartarch.yamas.dsl.xDSL.ExperimentTaskConfiguraiton;
import cz.smartarch.yamas.dsl.xDSL.ExperimentTaskConfiguraitonBody;
import cz.smartarch.yamas.dsl.xDSL.Field;
import cz.smartarch.yamas.dsl.xDSL.Group;
import cz.smartarch.yamas.dsl.xDSL.Inclusive;
import cz.smartarch.yamas.dsl.xDSL.InputData;
import cz.smartarch.yamas.dsl.xDSL.Interaction;
import cz.smartarch.yamas.dsl.xDSL.Join;
import cz.smartarch.yamas.dsl.xDSL.MetaData;
import cz.smartarch.yamas.dsl.xDSL.Metric;
import cz.smartarch.yamas.dsl.xDSL.NodeLink;
import cz.smartarch.yamas.dsl.xDSL.OutputData;
import cz.smartarch.yamas.dsl.xDSL.Parallel;
import cz.smartarch.yamas.dsl.xDSL.ParallelNodes;
import cz.smartarch.yamas.dsl.xDSL.Param;
import cz.smartarch.yamas.dsl.xDSL.ParamValue;
import cz.smartarch.yamas.dsl.xDSL.ParamValueEnum;
import cz.smartarch.yamas.dsl.xDSL.ParamValueList;
import cz.smartarch.yamas.dsl.xDSL.ParamValueRange;
import cz.smartarch.yamas.dsl.xDSL.PrimitiveType;
import cz.smartarch.yamas.dsl.xDSL.RegularExpLink;
import cz.smartarch.yamas.dsl.xDSL.RegularLink;
import cz.smartarch.yamas.dsl.xDSL.RegularLinks;
import cz.smartarch.yamas.dsl.xDSL.Root;
import cz.smartarch.yamas.dsl.xDSL.Structure;
import cz.smartarch.yamas.dsl.xDSL.SubstitutedTask;
import cz.smartarch.yamas.dsl.xDSL.Task;
import cz.smartarch.yamas.dsl.xDSL.TaskConfiguration;
import cz.smartarch.yamas.dsl.xDSL.TaskSpecification;
import cz.smartarch.yamas.dsl.xDSL.XDSLPackage;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class XDSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private XDSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == XDSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case XDSLPackage.ACTION:
				sequence_Action(context, (cz.smartarch.yamas.dsl.xDSL.Action) semanticObject); 
				return; 
			case XDSLPackage.ACTION_ARGUMENT:
				sequence_ActionArgument(context, (ActionArgument) semanticObject); 
				return; 
			case XDSLPackage.ARRAY:
				sequence_Array(context, (Array) semanticObject); 
				return; 
			case XDSLPackage.ASSEMBLED_WORKFLOW:
				sequence_AssembledWorkflow(context, (AssembledWorkflow) semanticObject); 
				return; 
			case XDSLPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case XDSLPackage.CASE:
				sequence_Case(context, (Case) semanticObject); 
				return; 
			case XDSLPackage.COMPOSITE_WORKFLOW:
				sequence_CompositeWorkflow(context, (CompositeWorkflow) semanticObject); 
				return; 
			case XDSLPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case XDSLPackage.CONDITIONAL_EXP_LINK:
				sequence_ConditionalExpLink(context, (ConditionalExpLink) semanticObject); 
				return; 
			case XDSLPackage.CONDITIONAL_LINK:
				sequence_ConditionalLink(context, (ConditionalLink) semanticObject); 
				return; 
			case XDSLPackage.CONTROL:
				sequence_Control(context, (Control) semanticObject); 
				return; 
			case XDSLPackage.DATA_CONFIGURATION:
				sequence_DataConfiguration(context, (DataConfiguration) semanticObject); 
				return; 
			case XDSLPackage.DATA_LINK:
				sequence_DataLink(context, (DataLink) semanticObject); 
				return; 
			case XDSLPackage.DEPENDENCY:
				sequence_Dependency(context, (Dependency) semanticObject); 
				return; 
			case XDSLPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case XDSLPackage.EXCEPTIONAL_LINK:
				sequence_ExceptionalLink(context, (ExceptionalLink) semanticObject); 
				return; 
			case XDSLPackage.EXCLUSIVE:
				sequence_Exclusive(context, (Exclusive) semanticObject); 
				return; 
			case XDSLPackage.EXPERIMENT:
				sequence_Experiment(context, (Experiment) semanticObject); 
				return; 
			case XDSLPackage.EXPERIMENT_SPACE:
				sequence_ExperimentSpace(context, (ExperimentSpace) semanticObject); 
				return; 
			case XDSLPackage.EXPERIMENT_TASK:
				sequence_ExperimentTask(context, (ExperimentTask) semanticObject); 
				return; 
			case XDSLPackage.EXPERIMENT_TASK_CONFIGURAITON:
				sequence_ExperimentTaskConfiguraiton(context, (ExperimentTaskConfiguraiton) semanticObject); 
				return; 
			case XDSLPackage.EXPERIMENT_TASK_CONFIGURAITON_BODY:
				sequence_ExperimentTaskConfiguraitonBody(context, (ExperimentTaskConfiguraitonBody) semanticObject); 
				return; 
			case XDSLPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case XDSLPackage.GROUP:
				sequence_Group(context, (Group) semanticObject); 
				return; 
			case XDSLPackage.INCLUSIVE:
				sequence_Inclusive(context, (Inclusive) semanticObject); 
				return; 
			case XDSLPackage.INPUT_DATA:
				sequence_InputData(context, (InputData) semanticObject); 
				return; 
			case XDSLPackage.INTERACTION:
				sequence_Interaction(context, (Interaction) semanticObject); 
				return; 
			case XDSLPackage.JOIN:
				sequence_Join(context, (Join) semanticObject); 
				return; 
			case XDSLPackage.META_DATA:
				sequence_MetaData(context, (MetaData) semanticObject); 
				return; 
			case XDSLPackage.METRIC:
				sequence_Metric(context, (Metric) semanticObject); 
				return; 
			case XDSLPackage.NODE_LINK:
				sequence_NodeLink(context, (NodeLink) semanticObject); 
				return; 
			case XDSLPackage.OUTPUT_DATA:
				sequence_OutputData(context, (OutputData) semanticObject); 
				return; 
			case XDSLPackage.PARALLEL:
				sequence_Parallel(context, (Parallel) semanticObject); 
				return; 
			case XDSLPackage.PARALLEL_NODES:
				sequence_ParallelNodes(context, (ParallelNodes) semanticObject); 
				return; 
			case XDSLPackage.PARAM:
				sequence_Param(context, (Param) semanticObject); 
				return; 
			case XDSLPackage.PARAM_VALUE:
				sequence_ParamValue(context, (ParamValue) semanticObject); 
				return; 
			case XDSLPackage.PARAM_VALUE_ENUM:
				sequence_ParamValueEnum(context, (ParamValueEnum) semanticObject); 
				return; 
			case XDSLPackage.PARAM_VALUE_LIST:
				sequence_ParamValueList(context, (ParamValueList) semanticObject); 
				return; 
			case XDSLPackage.PARAM_VALUE_RANGE:
				sequence_ParamValueRange(context, (ParamValueRange) semanticObject); 
				return; 
			case XDSLPackage.PARAMETER:
				sequence_Parameter(context, (cz.smartarch.yamas.dsl.xDSL.Parameter) semanticObject); 
				return; 
			case XDSLPackage.PRIMITIVE_TYPE:
				sequence_PrimitiveType(context, (PrimitiveType) semanticObject); 
				return; 
			case XDSLPackage.REGULAR_EXP_LINK:
				sequence_RegularExpLink(context, (RegularExpLink) semanticObject); 
				return; 
			case XDSLPackage.REGULAR_LINK:
				sequence_RegularLink(context, (RegularLink) semanticObject); 
				return; 
			case XDSLPackage.REGULAR_LINKS:
				sequence_RegularLinks(context, (RegularLinks) semanticObject); 
				return; 
			case XDSLPackage.ROOT:
				sequence_Root(context, (Root) semanticObject); 
				return; 
			case XDSLPackage.STRUCTURE:
				sequence_Structure(context, (Structure) semanticObject); 
				return; 
			case XDSLPackage.SUBSTITUTED_TASK:
				sequence_SubstitutedTask(context, (SubstitutedTask) semanticObject); 
				return; 
			case XDSLPackage.TASK:
				sequence_Task(context, (Task) semanticObject); 
				return; 
			case XDSLPackage.TASK_CONFIGURATION:
				sequence_TaskConfiguration(context, (TaskConfiguration) semanticObject); 
				return; 
			case XDSLPackage.TASK_SPECIFICATION:
				sequence_TaskSpecification(context, (TaskSpecification) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     ActionArgument returns ActionArgument
	 *
	 * Constraint:
	 *     (string=STRING | id=ID)
	 * </pre>
	 */
	protected void sequence_ActionArgument(ISerializationContext context, ActionArgument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns Action
	 *
	 * Constraint:
	 *     (actionName=ID (arguments+=ActionArgument arguments+=ActionArgument*)?)
	 * </pre>
	 */
	protected void sequence_Action(ISerializationContext context, cz.smartarch.yamas.dsl.xDSL.Action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterType returns Array
	 *     Array returns Array
	 *
	 * Constraint:
	 *     (name=ID length=INT type=ParameterType?)
	 * </pre>
	 */
	protected void sequence_Array(ISerializationContext context, Array semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Workflow returns AssembledWorkflow
	 *     AssembledWorkflow returns AssembledWorkflow
	 *
	 * Constraint:
	 *     (name=ID parent=[Workflow|ID] (inputs+=InputData | outputs+=OutputData | substitutedTasks+=SubstitutedTask)*)
	 * </pre>
	 */
	protected void sequence_AssembledWorkflow(ISerializationContext context, AssembledWorkflow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (name=ID attributeValue=ParamValue)
	 * </pre>
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.ATTRIBUTE__NAME));
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.ATTRIBUTE__ATTRIBUTE_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.ATTRIBUTE__ATTRIBUTE_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAttributeAccess().getAttributeValueParamValueParserRuleCall_2_0(), semanticObject.getAttributeValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Case returns Case
	 *
	 * Constraint:
	 *     (case=STRING target=[Node|ID])
	 * </pre>
	 */
	protected void sequence_Case(ISerializationContext context, Case semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.CASE__CASE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.CASE__CASE));
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.CASE__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.CASE__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCaseAccess().getCaseSTRINGTerminalRuleCall_0_0(), semanticObject.getCase());
		feeder.accept(grammarAccess.getCaseAccess().getTargetNodeIDTerminalRuleCall_1_0_1(), semanticObject.eGet(XDSLPackage.Literals.CASE__TARGET, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Workflow returns CompositeWorkflow
	 *     CompositeWorkflow returns CompositeWorkflow
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             inputs+=InputData | 
	 *             outputs+=OutputData | 
	 *             links+=Link | 
	 *             dataLinks+=DataLink | 
	 *             nodes+=Node | 
	 *             dataConfigurations+=DataConfiguration
	 *         )*
	 *     )
	 * </pre>
	 */
	protected void sequence_CompositeWorkflow(ISerializationContext context, CompositeWorkflow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (condition=STRING cases+=Case+)
	 * </pre>
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExperimentFlow returns ConditionalExpLink
	 *     ConditionalExpLink returns ConditionalExpLink
	 *
	 * Constraint:
	 *     (fromNode=[ExperimentNode|ID] toNode=[ExperimentNode|ID] condition=STRING)
	 * </pre>
	 */
	protected void sequence_ConditionalExpLink(ISerializationContext context, ConditionalExpLink semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.CONDITIONAL_EXP_LINK__FROM_NODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.CONDITIONAL_EXP_LINK__FROM_NODE));
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.CONDITIONAL_EXP_LINK__TO_NODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.CONDITIONAL_EXP_LINK__TO_NODE));
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.CONDITIONAL_EXP_LINK__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.CONDITIONAL_EXP_LINK__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalExpLinkAccess().getFromNodeExperimentNodeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(XDSLPackage.Literals.CONDITIONAL_EXP_LINK__FROM_NODE, false));
		feeder.accept(grammarAccess.getConditionalExpLinkAccess().getToNodeExperimentNodeIDTerminalRuleCall_2_0_1(), semanticObject.eGet(XDSLPackage.Literals.CONDITIONAL_EXP_LINK__TO_NODE, false));
		feeder.accept(grammarAccess.getConditionalExpLinkAccess().getConditionSTRINGTerminalRuleCall_5_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Link returns ConditionalLink
	 *     ConditionalLink returns ConditionalLink
	 *
	 * Constraint:
	 *     (input=NodeLink output=NodeLink condition=STRING)
	 * </pre>
	 */
	protected void sequence_ConditionalLink(ISerializationContext context, ConditionalLink semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.LINK__INPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.LINK__INPUT));
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.LINK__OUTPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.LINK__OUTPUT));
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.CONDITIONAL_LINK__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.CONDITIONAL_LINK__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalLinkAccess().getInputNodeLinkParserRuleCall_0_0(), semanticObject.getInput());
		feeder.accept(grammarAccess.getConditionalLinkAccess().getOutputNodeLinkParserRuleCall_2_0(), semanticObject.getOutput());
		feeder.accept(grammarAccess.getConditionalLinkAccess().getConditionSTRINGTerminalRuleCall_5_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Control returns Control
	 *
	 * Constraint:
	 *     (flows+=ExperimentFlow+ | notImplemented='...')?
	 * </pre>
	 */
	protected void sequence_Control(ISerializationContext context, Control semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataConfiguration returns DataConfiguration
	 *
	 * Constraint:
	 *     (data=[Data|ID] (path=STRING | type=STRING | defaultValue=ParamValue)*)
	 * </pre>
	 */
	protected void sequence_DataConfiguration(ISerializationContext context, DataConfiguration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DataLink returns DataLink
	 *
	 * Constraint:
	 *     ((inputDataTask=[Task|ID] asInputTask?='.')? inputData=[Data|ID] (outputDataTask=[Task|ID] asOutputTask?='.')? outputData=[Data|ID])
	 * </pre>
	 */
	protected void sequence_DataLink(ISerializationContext context, DataLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Dependency returns Dependency
	 *
	 * Constraint:
	 *     (name=ID value=STRING)
	 * </pre>
	 */
	protected void sequence_Dependency(ISerializationContext context, Dependency semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.DEPENDENCY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.DEPENDENCY__NAME));
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.DEPENDENCY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.DEPENDENCY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDependencyAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDependencyAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Node returns Event
	 *     Event returns Event
	 *
	 * Constraint:
	 *     name=EventValue
	 * </pre>
	 */
	protected void sequence_Event(ISerializationContext context, Event semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.EVENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.EVENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEventAccess().getNameEventValueEnumRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Link returns ExceptionalLink
	 *     ExceptionalLink returns ExceptionalLink
	 *
	 * Constraint:
	 *     (input=NodeLink output=NodeLink event=STRING)
	 * </pre>
	 */
	protected void sequence_ExceptionalLink(ISerializationContext context, ExceptionalLink semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.LINK__INPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.LINK__INPUT));
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.LINK__OUTPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.LINK__OUTPUT));
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.EXCEPTIONAL_LINK__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.EXCEPTIONAL_LINK__EVENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExceptionalLinkAccess().getInputNodeLinkParserRuleCall_0_0(), semanticObject.getInput());
		feeder.accept(grammarAccess.getExceptionalLinkAccess().getOutputNodeLinkParserRuleCall_2_0(), semanticObject.getOutput());
		feeder.accept(grammarAccess.getExceptionalLinkAccess().getEventSTRINGTerminalRuleCall_5_0(), semanticObject.getEvent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Node returns Exclusive
	 *     Operator returns Exclusive
	 *     Exclusive returns Exclusive
	 *
	 * Constraint:
	 *     (name=EXCLUSIVE_TERM conditions+=Condition+)
	 * </pre>
	 */
	protected void sequence_Exclusive(ISerializationContext context, Exclusive semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExperimentStep returns ExperimentSpace
	 *     ExperimentSpace returns ExperimentSpace
	 *     ExperimentNode returns ExperimentSpace
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         assembledWorkflow=[Workflow|ID] 
	 *         (strategy=ID | params+=Param | actions+=Action | attributes+=Attribute | taskConfigurations+=TaskConfiguration)*
	 *     )
	 * </pre>
	 */
	protected void sequence_ExperimentSpace(ISerializationContext context, ExperimentSpace semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExperimentTaskConfiguraitonBody returns ExperimentTaskConfiguraitonBody
	 *
	 * Constraint:
	 *     (params+=Param+ | notImplemented='...')?
	 * </pre>
	 */
	protected void sequence_ExperimentTaskConfiguraitonBody(ISerializationContext context, ExperimentTaskConfiguraitonBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExperimentTaskConfiguraiton returns ExperimentTaskConfiguraiton
	 *
	 * Constraint:
	 *     (task=[Task|ID] taskConfiguration=ExperimentTaskConfiguraitonBody)
	 * </pre>
	 */
	protected void sequence_ExperimentTaskConfiguraiton(ISerializationContext context, ExperimentTaskConfiguraiton semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.EXPERIMENT_TASK_CONFIGURAITON__TASK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.EXPERIMENT_TASK_CONFIGURAITON__TASK));
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.EXPERIMENT_TASK_CONFIGURAITON__TASK_CONFIGURATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.EXPERIMENT_TASK_CONFIGURAITON__TASK_CONFIGURATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExperimentTaskConfiguraitonAccess().getTaskTaskIDTerminalRuleCall_1_0_1(), semanticObject.eGet(XDSLPackage.Literals.EXPERIMENT_TASK_CONFIGURAITON__TASK, false));
		feeder.accept(grammarAccess.getExperimentTaskConfiguraitonAccess().getTaskConfigurationExperimentTaskConfiguraitonBodyParserRuleCall_2_0(), semanticObject.getTaskConfiguration());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExperimentStep returns ExperimentTask
	 *     ExperimentTask returns ExperimentTask
	 *     ExperimentNode returns ExperimentTask
	 *
	 * Constraint:
	 *     (
	 *         (name=ID abstract?=';') | 
	 *         (
	 *             name=ID 
	 *             configured?='{' 
	 *             (
	 *                 (
	 *                     inputs+=InputData | 
	 *                     outputs+=OutputData | 
	 *                     params+=Param | 
	 *                     description=STRING | 
	 *                     primitiveImplementation=STRING | 
	 *                     subworkflow=STRING | 
	 *                     dependency=STRING
	 *                 )? 
	 *                 (metadata+=MetaData metadata+=MetaData)?
	 *             )+
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_ExperimentTask(ISerializationContext context, ExperimentTask semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Experiment returns Experiment
	 *
	 * Constraint:
	 *     (name=ID intent=ID? (steps+=ExperimentStep | control=Control)*)
	 * </pre>
	 */
	protected void sequence_Experiment(ISerializationContext context, Experiment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Field returns Field
	 *
	 * Constraint:
	 *     (name=ID type=ParameterType?)
	 * </pre>
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Group returns Group
	 *
	 * Constraint:
	 *     (name=ID tasks+=[Task|ID] tasks+=[Task|ID]*)
	 * </pre>
	 */
	protected void sequence_Group(ISerializationContext context, Group semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Node returns Inclusive
	 *     Operator returns Inclusive
	 *     Inclusive returns Inclusive
	 *
	 * Constraint:
	 *     (name=INCLUSIVE_TERM conditions+=Condition+)
	 * </pre>
	 */
	protected void sequence_Inclusive(ISerializationContext context, Inclusive semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Data returns InputData
	 *     InputData returns InputData
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_InputData(ISerializationContext context, InputData semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.DATA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.DATA__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputDataAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExperimentStep returns Interaction
	 *     Interaction returns Interaction
	 *     ExperimentNode returns Interaction
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Interaction(ISerializationContext context, Interaction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.INTERACTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.INTERACTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInteractionAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Node returns Join
	 *     Operator returns Join
	 *     Join returns Join
	 *
	 * Constraint:
	 *     name=JOIN_TERM
	 * </pre>
	 */
	protected void sequence_Join(ISerializationContext context, Join semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.OPERATOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.OPERATOR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJoinAccess().getNameJOIN_TERMTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MetaData returns MetaData
	 *
	 * Constraint:
	 *     (name=STRING value=STRING)
	 * </pre>
	 */
	protected void sequence_MetaData(ISerializationContext context, MetaData semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.META_DATA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.META_DATA__NAME));
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.META_DATA__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.META_DATA__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMetaDataAccess().getNameSTRINGTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMetaDataAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Metric returns Metric
	 *
	 * Constraint:
	 *     (name=ID (type=ParameterType | kind=MetricKind)*)
	 * </pre>
	 */
	protected void sequence_Metric(ISerializationContext context, Metric semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NodeLink returns NodeLink
	 *
	 * Constraint:
	 *     (task=[Task|ID] | event=Event)
	 * </pre>
	 */
	protected void sequence_NodeLink(ISerializationContext context, NodeLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Data returns OutputData
	 *     OutputData returns OutputData
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_OutputData(ISerializationContext context, OutputData semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.DATA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.DATA__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutputDataAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParallelNodes returns ParallelNodes
	 *
	 * Constraint:
	 *     (nodes+=[ExperimentNode|ID] nodes+=[ExperimentNode|ID]+)
	 * </pre>
	 */
	protected void sequence_ParallelNodes(ISerializationContext context, ParallelNodes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Node returns Parallel
	 *     Operator returns Parallel
	 *     Parallel returns Parallel
	 *
	 * Constraint:
	 *     name=PARALLEL_TERM
	 * </pre>
	 */
	protected void sequence_Parallel(ISerializationContext context, Parallel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.OPERATOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.OPERATOR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParallelAccess().getNamePARALLEL_TERMTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParamValueEnum returns ParamValueEnum
	 *
	 * Constraint:
	 *     (values+=PrimitiveValue values+=PrimitiveValue*)
	 * </pre>
	 */
	protected void sequence_ParamValueEnum(ISerializationContext context, ParamValueEnum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParamValueList returns ParamValueList
	 *
	 * Constraint:
	 *     (values+=PrimitiveValue values+=PrimitiveValue*)
	 * </pre>
	 */
	protected void sequence_ParamValueList(ISerializationContext context, ParamValueList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParamValueRange returns ParamValueRange
	 *
	 * Constraint:
	 *     (start=INT end=INT step=INT?)
	 * </pre>
	 */
	protected void sequence_ParamValueRange(ISerializationContext context, ParamValueRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParamValue returns ParamValue
	 *
	 * Constraint:
	 *     (rangeValue=ParamValueRange | enumValue=ParamValueEnum | primitiveValue=PrimitiveValue | listValue=ParamValueList)
	 * </pre>
	 */
	protected void sequence_ParamValue(ISerializationContext context, ParamValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Param returns Param
	 *
	 * Constraint:
	 *     (name=ID (assigned?='=' (value=ParamValue | ref=[Param|ID]))?)
	 * </pre>
	 */
	protected void sequence_Param(ISerializationContext context, Param semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             type=ParameterType | 
	 *             defaultValueString=STRING | 
	 *             defaultValueInt=INT | 
	 *             rangeValue=ParamValueRange | 
	 *             enumValue=ParamValueEnum | 
	 *             valueConstraint=STRING
	 *         )*
	 *     )
	 * </pre>
	 */
	protected void sequence_Parameter(ISerializationContext context, cz.smartarch.yamas.dsl.xDSL.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterType returns PrimitiveType
	 *     PrimitiveType returns PrimitiveType
	 *
	 * Constraint:
	 *     {PrimitiveType}
	 * </pre>
	 */
	protected void sequence_PrimitiveType(ISerializationContext context, PrimitiveType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExperimentFlow returns RegularExpLink
	 *     RegularExpLink returns RegularExpLink
	 *
	 * Constraint:
	 *     (
	 *         started?='START'? 
	 *         (nodes+=[ExperimentNode|ID] | parallelNodes+=ParallelNodes) 
	 *         nodes+=[ExperimentNode|ID]? 
	 *         (parallelNodes+=ParallelNodes? nodes+=[ExperimentNode|ID]?)* 
	 *         ended?='-&gt;'?
	 *     )
	 * </pre>
	 */
	protected void sequence_RegularExpLink(ISerializationContext context, RegularExpLink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RegularLink returns RegularLink
	 *
	 * Constraint:
	 *     (input=NodeLink ouput=NodeLink)
	 * </pre>
	 */
	protected void sequence_RegularLink(ISerializationContext context, RegularLink semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.REGULAR_LINK__INPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.REGULAR_LINK__INPUT));
			if (transientValues.isValueTransient(semanticObject, XDSLPackage.Literals.REGULAR_LINK__OUPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XDSLPackage.Literals.REGULAR_LINK__OUPUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRegularLinkAccess().getInputNodeLinkParserRuleCall_0_0(), semanticObject.getInput());
		feeder.accept(grammarAccess.getRegularLinkAccess().getOuputNodeLinkParserRuleCall_2_0(), semanticObject.getOuput());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Link returns RegularLinks
	 *     RegularLinks returns RegularLinks
	 *
	 * Constraint:
	 *     (input=NodeLink links+=RegularLink* output=NodeLink)
	 * </pre>
	 */
	protected void sequence_RegularLinks(ISerializationContext context, RegularLinks semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Root returns Root
	 *
	 * Constraint:
	 *     ((asPackage?='package' name=ID) | ((asPackage?='package' name=ID) (workflows+=Workflow | groups+=Group | experiments+=Experiment)+))?
	 * </pre>
	 */
	protected void sequence_Root(ISerializationContext context, Root semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ParameterType returns Structure
	 *     Structure returns Structure
	 *
	 * Constraint:
	 *     (name=ID fields+=Field)
	 * </pre>
	 */
	protected void sequence_Structure(ISerializationContext context, Structure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SubstitutedTask returns SubstitutedTask
	 *
	 * Constraint:
	 *     (
	 *         name=[Task|ID] 
	 *         (
	 *             (
	 *                 inputs+=InputData | 
	 *                 outputs+=OutputData | 
	 *                 params+=Param | 
	 *                 description=STRING | 
	 *                 primitiveImplementation=STRING | 
	 *                 subworkflow=STRING | 
	 *                 dependency=STRING
	 *             )? 
	 *             (metadata+=MetaData metadata+=MetaData)?
	 *         )+
	 *     )
	 * </pre>
	 */
	protected void sequence_SubstitutedTask(ISerializationContext context, SubstitutedTask semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TaskConfiguration returns TaskConfiguration
	 *
	 * Constraint:
	 *     (
	 *         task=[Task|ID] 
	 *         (
	 *             (
	 *                 configured?='{' 
	 *                 (
	 *                     (
	 *                         inputs+=InputData | 
	 *                         outputs+=OutputData | 
	 *                         params+=Param | 
	 *                         description=STRING | 
	 *                         primitiveImplementation=STRING | 
	 *                         subworkflow=STRING | 
	 *                         dependency=STRING
	 *                     )? 
	 *                     (metadata+=MetaData metadata+=MetaData)?
	 *                 )+
	 *             ) | 
	 *             abstrac?=';'
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_TaskConfiguration(ISerializationContext context, TaskConfiguration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Workflow returns TaskSpecification
	 *     TaskSpecification returns TaskSpecification
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             inputs+=InputData | 
	 *             outputs+=OutputData | 
	 *             metrics+=Metric | 
	 *             parameters+=Parameter | 
	 *             implementation=STRING | 
	 *             dependencies+=Dependency
	 *         )*
	 *     )
	 * </pre>
	 */
	protected void sequence_TaskSpecification(ISerializationContext context, TaskSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Node returns Task
	 *     Task returns Task
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             abstract?=';' | 
	 *             (
	 *                 configured?='{' 
	 *                 (
	 *                     (
	 *                         inputs+=InputData | 
	 *                         outputs+=OutputData | 
	 *                         params+=Param | 
	 *                         description=STRING | 
	 *                         primitiveImplementation=STRING | 
	 *                         subworkflow=STRING | 
	 *                         dependency=STRING
	 *                     )? 
	 *                     (metadata+=MetaData metadata+=MetaData)?
	 *                 )+
	 *             )
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_Task(ISerializationContext context, Task semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
